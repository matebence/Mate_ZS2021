# -*- coding: utf-8 -*-
"""Mate_ZS2021.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vlaEtzfjhOZw1qZkNWeIzVEZAejHYNmW

# Ciele projektu

- importovanie datasetu
- analýza, úprava dát
- rozdelenie dát na trénovacie a testovacie
- vytvorenie rozhodovacieho stromu
- prevod na pravidlá
- upravenie pravidiel pre Clips
- vytvorenie použivateľského menu v Clips

V provom kroku si najprv zanalyzujeme náš dataset pomocou knižnice **pandas**. Ako tému sme si vybrali `'predpoved, že niekto dostane alebo má diabetes'`. Dataset môžeme nájsť na [tejto adrese](https://www.kaggle.com/uciml/pima-indians-diabetes-database) alebo na [gite](https://github.com/matebence/Mate_ZS2021/blob/master/diabetes.csv).  Už samotný názov témy naznačuje, že ako dáta bude musieť analyzovať zdravotný stav ľudi ako mužov aj ženy v rôznom veku.
"""

# knižnice pre analýzu dát
import pandas as pd
import numpy as np

# knižnice pre získanie datasetu
import requests
import io

# kedže náš dataset sa už nachádza v našom git repozirátri, tak to využijeme a pomocou knižnice requests urobíme GET požiadavku na získanie datasetu
url = "https://raw.githubusercontent.com/matebence/Mate_ZS2021/master/diabetes.csv"
response = requests.get(url).content
data_frame = pd.read_csv(io.StringIO(response.decode('utf-8')))

# náš dataset pozostáva z 768 riadkov a 9 stľpcov, kde shape[0] predstavuje riadky a shape[1] stľpce
data_frame.shape

# názvy stľpcov ktorými budeme pracovať
data_frame.columns

"""## Vysvetlenie význam stľpcov

- `Pregnancies (Tehotenstvo)` - Počet tehotenstiev
- `Glucose (Glukóza)` - Koncentrácia glukózy v plazme
- `BloodPressure (Krvný tlak)` - Krvný tlak (mm Hg)
- `SkinThickness (Hrúbka pokožky)` - Hrúbka záhybu pokožky (mm)
- `Insulin2-Hour (Inzulín)` - 2-hodinový sérový inzulín (mu U / ml)
- `BMI (Index telesnej hmotnosti)` - Index telesnej hmotnosti (hmotnosť v kg / (výška vm) ^ 2)
- `Age (Vek)` - Vek (roky)
- `Outcome (Výsledok)` - Premenná triedy výsledku (0 alebo 1) 268 z 768 je 1, ostatné sú 0
"""

# dátové typy stľpcov
data_frame.info()

# ukážka dát
data_frame.head(5)

# počet, priemer, max, min jednotlivých stľpcov
data_frame.describe()

"""### Počet ludí ktorí majú diabetes

Najdôležitejšie časti z kódu nižšie sú:

`'data_frame.Outcome.value_counts().plot.bar'` - získanie stľpca Outcome a počet hodnout pomocou count, následne vytvoriť **stľpcový graf**<br>
`'data_frame.Outcome.value_counts().plot.pie'` - získanie stľpca Outcome a počet hodnout pomocou count, následne vytvoriť **koláčový graf**

Všetko ostatné je iba nastovanie grafu pomocou **seaborn** dokumentáciu môžeme nájsť [tu](https://seaborn.pydata.org/).
"""

# knižnica pre znázornenie grafu
import matplotlib.pyplot as plt
import seaborn as sns

f, ax = plt.subplots(1, 2, figsize = (15, 7))
_ = data_frame.Outcome.value_counts().plot.bar(ax = ax[0], rot = 0, color = (sns.color_palette()[0], sns.color_palette()[2])).set(xticklabels = ["Nie", "Áno"])
_ = data_frame.Outcome.value_counts().plot.pie(labels = ("Nie", "Áno"), autopct = "%.2f%%", label = "", fontsize = 13., ax = ax[1],\
colors = (sns.color_palette()[0], sns.color_palette()[2]), wedgeprops = {"linewidth": 1.5, "edgecolor": "#F7F7F7"}), ax[1].texts[1].set_color("#F7F7F7"), ax[1].texts[3].set_color("#F7F7F7")

"""### Po analýze dát si posvietíme na správnosť dátových typov
 - Či všetky naše dáta sú numerické
"""

issues = [var for var in data_frame.columns if data_frame[var].dtype=='O']
print("Problémové stľpce sú : ", issues)

#knižnice pre generovanie rozhodovacieho stromu
from sklearn.tree import DecisionTreeClassifier
from sklearn.model_selection import train_test_split
from sklearn import metrics

# rozdelenie dát na vstup(feature) a výstup(label)
labels=data_frame['Outcome']
features = data_frame.iloc[:,0:8]
X=features
y=np.ravel(labels)

#rozdelenie dát na trénovacie a testovacie v pomere 20 - 80
# rozdelenie dát na trénovacie a testovacie
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)

X_train[:5]

#inicializujeme knižnicu pre rozhodovací strom a spustíme trénovanie dát pomocou metódy fit()
clf = DecisionTreeClassifier()
clf = clf.fit(X_train,y_train)

#zistíme presnosť pomocou metódy accuracy_score()
y_pred = clf.predict(X_test)
print("Presnosť:",metrics.accuracy_score(y_test, y_pred))

"""![Confusion matrix](https://miro.medium.com/max/445/1*Z54JgbS4DUwWSknhDCvNTQ.png)

- TP -> True Positive: Predpoklad je pozitívna hodnota a je to pravda.
- TN -> True Negative: Predpoklad je negatívna hodnota a je to pravda.
- FP -> False Positive: (Type 1 Error) Predpoklad je pozitívna hodnota ale výsledok je nepravdivý.
- FN -> False Negative: (Type 2 Error) Predpoklad je negatívna hodnota ale výsledok je nepravdivý.
"""

#meranie výkonu klasifikácie strojového učenia
from sklearn.metrics import confusion_matrix

print(confusion_matrix(y_test, y_pred))

#knižnice pre znázornenie rozhodovacieho stromu
import pydotplus
from sklearn.tree import export_graphviz
from sklearn.externals.six import StringIO  
from IPython.display import Image

#generovanie rozhodovacieho stromu
dot_data = StringIO()
export_graphviz(clf, out_file=dot_data, filled=True, rounded=False, special_characters=True,feature_names = list(X.columns),class_names=['Ano','Nie'])
graph = pydotplus.graph_from_dot_data(dot_data.getvalue())  
graph.write_png('skuska.png')
Image(graph.create_png())

#algoritmus služiaci na prevod pravidiel
import numpy as np
from sklearn.tree import _tree

def tree_to_code(tree, feature_names, Y):
    tree_ = tree.tree_
    feature_name = [
        feature_names[i] if i != _tree.TREE_UNDEFINED else "undefined!"
        for i in tree_.feature
    ]
    pathto=dict()

    global k
    k = 0
    def recurse(node, depth, parent):
        global k
        indent = "  " * depth

        if tree_.feature[node] != _tree.TREE_UNDEFINED:
            name = feature_name[node]
            threshold = tree_.threshold[node]
            s= "{} <= {} ".format( name, threshold, node )
            if node == 0:
                pathto[node]=s
            else:
                pathto[node]=pathto[parent]+' & ' +s

            recurse(tree_.children_left[node], depth + 1, node)
            s="{} > {}".format( name, threshold)
            if node == 0:
                pathto[node]=s
            else:
                pathto[node]=pathto[parent]+' & ' +s
            recurse(tree_.children_right[node], depth + 1, node)
        else:
            k=k+1
            print(k,')',pathto[parent], tree_.value[node])
    recurse(0, 1, 0)

#výpis pravidiel
tree_to_code(clf, list(X.columns), y_train)

"""### Využitie pravidiel v Clips
 - Teraz už iba prepíšeme pravidlá do programu Clips. Celý program možeme najsť na [tejto adrese](https://github.com/matebence/Mate_ZS2021/blob/master/diabetes.clp).
"""